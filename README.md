# 1.稀疏数组用于简化二维数组

即用一个简单的数组来保存二维数组中有意义的位置与值(将二维数组看作一个坐标系),稀疏数组的第0个元素用于存储二维数组的行列数和有效值数

运用场景(五子棋的记录保存)

代码见编译器DataStructures项目sparseArray包

# 2.队列(可以用数组也可以用链表)

特点:先进先出

## (1)普通队列

队头会随着数据的输出而改变,队尾会随着数据的输入而改变

当rear == MaxSize - 1;时即队列已满

front == rear 队列为空(front指向队列的第一个元素的前一个位置,rear指向队列的最后一个元素)

代码见DataStructures项目queue包

缺点:数组使用一次就无法使用了,无法对其进行复用

## (2)环形队列

调整:使front(front = 0 )指向队列的第一个元素,rear(rear = 0)指向队列的最后一个元素的后一个位置

当队列满时(rear + 1) % MaxSize = front

当队列为空:front == rear 

队列中有效的个数为(rear + MaxSize - front) % MaxSize

代码见DataStructures项目queue包

# 3.链表

链表是以节点的方式来储存(分为带头结点的和不带头结点的)

每个节点包含	data域:用于存放数值,信息等		next域:指向下一节点

链表的各个节点不一定连续储存

## (1)单链表

头节点不存放具体的数据,作用就是表示单链表的头

当链表节点next域为空时,链表结束

单向链表查找只能是一个方向,并且不能自我删除,需要靠辅助节点.

代码见DataStructures项目linkedlist包

## (2)双向链表

双向链表可以进行自我删除,而且不需要辅助节点

## (3)单向环形链表

创建一个first指向指向第一个节点

当最后一个节点的next == first 时 结束

# 4.栈

特点:先入后出

有序列表,运行操作变化的一端为栈顶,另一端固定的为栈底

(可用数组或链表来实现)

##### 中缀表达式转后缀表达式的分析

例子:1+((2+3)*4)-5   =>

1.建立两个栈,一个用于存放符号(符号栈),一个存放数字(算式栈)

2从左到右进行扫描,遇到数字压入算式栈

遇到符号先先比较其与符号栈栈顶元素的优先级

如果是空栈直接压入

如果优先级高于栈顶元素,也直接压入

否则先将符号栈中栈顶元素弹出,压入算式栈

在让刚刚的符号与新的栈顶进行比较

遇到括号时,如果是"("直接压入栈中,如果")"依次弹出符号栈中的运算符

直到弹出"("为止,此时将一对括号舍弃

重复上述操作

3.最后将符号栈中剩余符号弹出依次压入算式栈

4.此时所得即转换成功的后缀表达式

代码见DataStructures项目

# 5.递归

递归的概念:就是一个方法直接调用自己,每次调用时传入不同的变量

可以使代码变得简洁

## 递归调用规则

1.当程序执行到一个方法时,就会开辟一个独立的空间(栈)

2.方法中的局部变量是独立的,不会相互影响

3.如果方法中使用的是引用类型变量,就会影响该引用类型数据

4.递归必须向退出递归的条件逼近,否则就是无限递归

5.当一个方法执行完毕或者返回时,该方法就执行完毕了

代码见DataStructures项目

### 时间频度

一个算法中的语句执行次数称为语句频度或时间频度,记为T(n)

随着n的变大可忽略常数项和低次项,还可以忽略系数

### 时间复杂度

若某个辅助函数f(n)能使当n趋近于无穷大时,T(n)/f(n)的极限值为不等于0的常数,则称f(n)是T(n)的同数量级函数.记作T(n) = O(f(n)),称O(f(n))为算法的渐进时间复杂度,简称时间复杂度

T(n)不同,时间复杂度可能相同

#### 计算时间复杂度的方法:

用常数1代替运行时间中的所有加法常数

修改后的运行次数函数中,只保留最高阶项

去除最高阶系数

一般情况下讨论的是最坏时间复杂度

# 6.排序

## (1)冒泡排序

基本思想:通过对待排序序列从前向后(从下标较小的元素开始),依次开始比较,相邻的元素的值,若发现逆序则交换,使值较大的元素逐渐从前向后移动,就像水泡一样,逐渐上冒,在排序过程中各元素逐渐接近自己的位置

依次遍历,两两比较,如果逆序则进行交换

例子:先比第一个数和第二个数.如果第一个数大于第二个数则两个数交换,否则反之,接着比较第二个与第三个重复上述操作

规则:

一共进行数组大小-1次大的循环

每一趟排序(交换)的次数在逐渐减小

优化:如果发现在某趟排序中没有发生交换,则可以提前结束排序

## (2)选择排序

基本思想:第一次从arr[0]~arr[n - 1]中选取最小值,与arr[0]交换,第二次   arr[1]~arr[n-1]中选取最小值,与arr[1]交换,以此类推进行到n-1次,  得到一个有序序列

说明:

1.选择排序一共有数组大小-1次排序

2.每1轮排序,又是一个循环,循环规则(代码)

2.1先假定当前数是最小的

2.2然后依次进行比较,如果有比其小的数,就重新确定最小数,并得到下表

2.3当数组遍历完成后,便得到了本轮最小数和下标

2.4交换

## (3)插入排序

基本思想:把n个待排序的元素看成为一个有序表和一个无序表,开始时有序表中只包含一个元素,无序表中包含n-1个元素,排序过程中每次从无序表中取出一个元素,把它的排序码依次与有序表元素进行比较,将它插入到有序表中适当位置,使之成为新的有序表.

## (4)希尔排序

希尔排序时简单插入排序改进后的一个更加高效的版本;

基本思想:希尔排序是把记录按下标的一定增量分组,对每组使用直接插入排序算法排序;随着增量的减少,每组包含的关键词越来越多,当增量减至1时,整个文件恰被分成一组,算法便终止.

## (5)快速排序

快速排序是对冒泡排序的一种改进.

基本思想:通过一趟排序将要排序的数据分割成独立的两个部分,其中一部分的所有数据都比另外一部分的所有数据要小,然后再按此方法对这两个部分数据分别进行快速排序,整个排序过程可以递归进行,以此达到整个数据变成有序序列 .

## (6)归并排序

归并排序是利用归并的思想实现的排序方法,该算法采用经典的分治策略

分治法将问题分成一些小的问题然后递归求解,而治的阶段则将分的阶段得到的各答案"修补"在一起,即分而治之

## (7)基数排序

基数排序属于"分配式排序",又称为"桶子法",顾名思义,它是通过各个位的值,将要排序的元素分配至某些"桶"中,达到排序的作用

实现:将证书按位数切割成不同数字,然后按照各个位数分别比较

基本思想:将所有待比较的数值统一为同样的数位长度,数位较短的数前面补零,然后,从最低位开始,依次进行一次排序.这样从最低位排序一直到最高位排序完成后,数列就变成一个有序序列了.

不支持负数;

如何判断是否稳定,如果两个值相同的数据排序后位置不变则稳定

## (8)堆排序

### --树结构的实际应用

1)堆排序是一种选择排序.最好,最坏,平均时间复杂度均为O(nlogn),它也是不稳定排序

2)堆是具有以下性质的完全二叉树,每个节点的值都大于或等于其左右孩子节点的值,称为大顶堆,注意:没有要求节点的左孩子的值和有孩子的大小关系

3)每个节点的值都小于或等于其左右孩子的节点值,成为小顶堆

4)一般升序使用大顶堆,降序使用小顶堆

基本思想:

1)将待排序序列构造成一个大顶堆[树以数组的形式存放]

2)此时,整个序列的最大值就是堆顶的根节点

3)将其与末尾元素进行交换,此时末尾就为最大值

4)然后将剩余n-1个元素重新构造成一个堆,这样就会得到n个元素的次小值,如此反复执行,便能得到一个有序序列了.

注:可以看到在构建大顶堆的过程中,元素的个数逐渐减少,最后就得到一个有序序列

# 7.查找

## (1)线性查找

线性查找是逐一比对发现有相同的值时就返回下标.

## (2)二分查找

只能在有序数组中使用;
$$
mid = (low + high) / 2 =0.5 * (high - low) + low
$$
两种代码方式(递归与非递归)

## (3)插值查找

改进后的二分查找
$$
mid = low + (key - a[low]) / (a[high] - a[low]) * (high - low)
$$
key即所查找的数;

注意事项:

1)对于数据数量较大,关键字分布比较均匀的查找表来说,采用插值查找,速度比较快

2)关键字分布不均匀的情况下,该方法不一定比折半查找好

## (4)斐波那契查找(黄金分割法)

$$
mid = low + F[k - 1]-1
$$

F代表斐波那契数列

使用时需要构建斐波那契数列

# 8.哈希表(散列表)

散列表是根据关键码值而直接进行访问的数据结构,也就是说,它通过把关键码值映射到表中一个位置来访问记录,以加快查找速度.这个记录函数叫散列函数,存放记录的数组叫做散列表.

# 9.树

树存储方式的分析:

能提高数据存储,读取的效率,比如利用二叉排序树,既可以保证数据的检索速度,同时也可以保证数据的插入,删除,修改的速度.

## (1)二叉树

1)每个节点只能有两个子节点

2)二叉树的节点分别为左节点和右节点

3)如果该二叉树的所有叶子节点都在最后一层,并且节点总数 - 2^n-,n为层数,则我们称为满二叉树.

4)如果噶爱二叉树的所有叶子节点都在最后一层或者倒数第二层,而且最后一层的叶子节点在左边连续,倒数第二层的叶子节点在右边连续,我们称为完全二叉树.

遍历:

前序遍历:先输出父节点,再遍历左子树和右子树

中序遍历:先遍历左子树,再输出父节点,再遍历右子树

后序遍历:先遍历左子树,再遍历右子树,最后输出父节点

## (2)顺序存储二叉树

从数据存储来看,数组存储方式和数的存储方式可以相互转换,即数组可以转换成树,树也可以转换成数组

## (3)线索化二叉树

1)n个节点的二叉树链表中含有n+1公式2n-(n-1)=n+1个空指针域.利用二叉链表中的空指针域,存放指向节点在某种遍历次序下的前驱和后继节点的指针

2)可以分为前序线索二叉树,中序线索二叉树,后序线索二叉树

## (4)赫夫曼树

基本介绍:

1)给定n个权值作为n个叶子节点,构造一棵二叉树,若该树的带权路径长度达到最小,称这样的二叉树为最优二叉树,也称为赫夫曼树

2)赫夫曼树是带权路径长度最短的树,权值较大的节点离根比较近

权值越大的叶子节点离根节点越近的二叉树才是最优二叉树

### 构建赫夫曼树的步骤:

1)从小到大进行排序,将每一个数据,每一个数据都是一个节点,每一个节点可以看成一棵简单的二叉树

2)取出根节点权值最小的两棵二叉树

3)组成一棵新的二叉树,该新的二叉树的根节点的权值是前面两根二叉树节点权值的和

4)再将这棵二叉树,以根节点的权值大小在排序,不断重复上述步骤,直到数列中,所有数据都被处理,就得到一棵赫夫曼树

## 赫夫曼编码:

原理:

1)统计各个字符出现的次数

2)按照各个字符出现的次数构建一颗赫夫曼树,次数作为权值

3)根据赫夫曼树,给各个字符进行编码,向左的路径为0,向右的路径为1.

因为可能存在相同权值,所以所见赫夫曼树可能不一样,但是对同一句子编码长度不会改变.

## (5)二叉排序树

对于二叉排序树的任何一个非叶子节点,要求左子节点的值比当前节点的值小,右子节点的值比当前节点的值打.

特别说明:如果有相同的值,可以将该节点放到左子树或右子树

## (6)平衡二叉树

基本介绍:

平衡二叉树也叫平衡二叉搜索树又被称为AVL树,可以保证查询的效率较高

特点:

它是一棵空树或它的左右两个子树的高度差的绝对值不超过1,并且左右两个子树都是一棵平衡二叉树.平衡二叉树的常用实现方法(算法)有红黑树,AVL,替罪羊树,Treap,伸展树等.

## (7)多路查找树

1)在二叉树中,每个节点有数据项,最多有两个子节点,如果允许每个节点可以有更多的数据项和更多的子节点,就是多叉树.

2)后面我们讲解的2-3树,2-3-4树就是多叉树,多叉树通过重新组织节点,减少树的高度,能对二叉树进行优化.

### B树(平衡树)

B树通过重新组织节点,降低树的高度(即一个数据项(节点)可以放多个数据)

节点的度:这个节点下子树的个数;

树的度:节点的度中最大的值

#### 2-3树

特点:

1)所有叶子节点必须在同一层(只要是B树都满足这个条件)

2)有两个子节点的节点叫二节点,二节点要么没有子节点,要么有两个子节点.

3)有三个子节点的节点叫三节点,三节点要么没有子节点,要么三个子结点.

4)2-3树是由二节点和三节点构成的树.

### B+树

特点所有的关键字都出现在叶子节点的链表中,非叶子节点为索引

### B*树

B+树的变体,增加了非叶子节点指向兄弟节点的指针

# 10.图

常用概念:

(1)顶点(vertex)(2)边(edge)(3)路径(4)无向图(5)有向图(6)带权图

图的表示方式:

二维数组表示(邻接矩阵);链表表示(邻接表)

邻接矩阵:表示图形中顶点之间相邻关系,对于n个顶点的图而言,矩阵的row和col表示的是1...n个点

邻接表:

1)邻接矩阵需要为每个顶点都分配n个边的空间,其实有很多都是不存在的,会造成空间的一定损失.

2)邻接表的实现只关心存在的边,不关心不存在的边,因此没有空间的浪费,邻接表由数组加链表组成

## (1)图的遍历

一般分为两种访问策略:(1)深度优先遍历(2)广度优先遍历

深度优先的基本思想:

1)深度优先遍历,从初始访问节点出发,初始访问节点可能有多个相邻的节点,深度优先遍历的策略就是首先访问第一个邻接结点,然后再以这个被访问的邻接节点作为初始节点,访问它的第一个邻接结点,可以这样理解每次都在访问完当前节点后首先访问当前节点的第一个邻接结点.

2)我们可以看到,这样的访问策略是优先往纵向挖掘深入,而不是对一个节点的所有邻接结点进行横向访问

3)显然,深度优先搜索是一个递归的过程

广度优先遍历的基本思想:

类似于一个分层搜索的过程,广度优先遍历需要使用一个队列以保持访问过的节点的顺序,以便按这个顺序来访问这些节点的邻接结点

# 11.常用的10种算法

## (1)分治算法

1)二分查找(非递归)

较简单.见代码

基本介绍:

就是把一个复杂的问题分成两个或更多的相同 或相似的子问题,再把子问题分成更小的子问题.....直到最后子问题可以简单的直接最后子问题可以简单的直接求解,原问题的解即子问题的解直接合并.

### 分治算法的基本步骤

分治法在每一层的递归上都有三个步骤:

1)分解:将原问题分解为若干个规模较小,相互独立,与原问题形式相同的子问题

2)解决:若子问题规模较小而容易被解决则直接解,否则递归地解决各个子问题

3)合并:将各个子问题的解决合并为原问题的解

## (2)动态规划算法

核心思想:将大的问题划分为小问题进行解决,从而一步步获取最优解的处理算法;

与分治算法类似,其基本思想也是将问题分解成若干个子问题,先求解子问题,然后从这些子问题的解得到原问题的解.

与分治法不同的是,适用于用动态规划求解问题,经分解得到子问题往往不是相互独立的.(即下一个子阶段的求解的求解是建立在上一个子阶段的解的基础上,进行进一步求解)

动态规划可以通过填表来逐步推进,得到最优解

## (3)KMP算法

1)kmp是一个解决模式串在文本串是否出现过,如果出现过,最早出现的位置的经典算法

2)kmp算法就利用之前判断过的信息,通过一个next数组,保存模式串中前后最长公共子序列的长度,每次回溯时,通过next数组找到,前面匹配过的位置,省去了大量的计算时间.

3)核心j位置的重置j = next[j - 1];

## (4)贪心算法

1)贪婪算法是指在对问题进行求解时,在每一步选择都采取最好或者最优的选择,从而希望能够导致结果是最好或者最优的算法

2)贪婪算法所得到的结果不一定是最优结果(有时可能是最优解),但是都是相近似(接近最优解)的结果

## (5)普利姆算法

普利姆算法是求最小生成树,也就是在包含n个顶点的连通图中,找出只有(n-1)跳变包含所有n戈丁底单的连通子图,也就是所谓的极小连通图

算法如下:

1)设G=(V,E)是连通图,T=(U,D)是最小生成树,V,U是顶点集合, E,D是边的集合

2)若从顶点u开始构造最小生成树,则从集合V中取出顶点u放入集合中,标记顶点v的visited[u] = 1

3)若集合U中顶点ui与集合V-U中的顶点vj之间存在边,则寻找这些边中权值最小的边,但不能构成回路,将顶点vj加入集合U中,将边(ui,vj)加入集合D中,标记visiited[vj]=1

4)重复步骤(2),直到u与v相等,即所有顶点都被标记为访问过,此时D中有n-1条边

## (6)克鲁斯卡尔算法

1)克鲁斯卡尔算法,是用来求加权连通图的最小生成树的算法.

2)基本思想:按照权值从小到大的顺序选择n-1条边,并保证这n-1条边不构成回路

3)具体做法:首先构造一个只含n个顶点的森林,然后依权值从小到大从连通网中选择边加入到森林中,并使森林中不产生回路,直至森林变成一棵树为止.

## (7)迪杰斯特拉算法

用于计算一个节点到其他节点的最短路径.它的主要特点是以起始点为中心向外层扩展(广度优先的思想),直到扩展到终点为止.

算法过程:

设置出发点为v,顶点集合V[v1....],v到V中各个顶点的距离构成距离集合Dis,Dis[d1,d2,di...],Dis集合记录看v到图中各个顶点的距离(到自身可以看作0,v到vi距离对应为di)

1)从Dis中选择值最小的di并移出Dis集合,同时移出V集合中对应的顶点vi,此时的v到vi即为最短路径

2)更新Dis集合,更新规则为:比较v到V集合中顶点的距离值,与v通过vi到V集合中顶点的距离值,保留值较小的一个(同时也应该更新顶点的前驱节点为vi,表明是通过vi达到的)

3)重复执行两步骤,直到最短路径顶点为目标顶点即可结束

## (8)弗洛伊德算法

1)设置顶点vi到顶点vk的最短路径已知为Lik,顶点vk到vj的最短路径已知为Lkj,顶点vi到vj的路径为Lij,则vi到vj的最短路径为:min((Lik+Lk),Li),vk的取值为图中所有顶点,则可以获得vi到vj的最短路径

2)至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj,是以同样方式获得

